{"version":3,"sources":["../../../units/rb-base-server/ObjectCache.js"],"names":["expirationCheckInterval","expirationIntervalTimer","MapCachesByCategory","Map","initializeObjectCache","definition","CacheableCategoryDefinitions","set","name","entries","executeDiscard","cacheKey","discardFunction","objectPromise","err","message","NestedError","cleanupCategory","cachedEntriesForCategory","size","countMax","arrCreatedTime","cachedEntry","values","push","createdTimeMs","sort","a","b","cutOffTimeMs","onDiscard","delete","removeExpired","debugWriteToConsoleObjectCacheActivity","logEntries","bPerishableItemsLeft","timeMsNow","Date","getTime","expirationDurationMs","expiresAtMs","clearInterval","addObjectToCache","categoryName","get","Error","validByTimeMs","validityDurationMs","validityVerificationPromise","creationPromise","setInterval","getObjectFromCache","getCachedEntryFromCache","isValid","validityVerifier","Promise","resolve","getOrCreateObjectFromCahce","creationFunction","currentCachedEntry","newObjectPromise","title","display","key","validBy","validByLeft","expires","expiresLeft","console","log","table"],"mappings":"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","sourcesContent":["// @flow\n\nimport NestedError from 'nested-error-stacks'\n\nimport CacheableCategoryDefinitions from '../_configuration/rb-base-server/CacheableCategoryDefinitions'\nimport { debugWriteToConsoleObjectCacheActivity } from '../_configuration/debug'\n\nimport log from './log'\nimport type { CachedEntriesForCategory, CachedEntry } from './types/ObjectCache.types'\n\nconst expirationCheckInterval = 5000\nlet expirationIntervalTimer = null\n\nconst MapCachesByCategory: Map<string, CachedEntriesForCategory> = new Map()\n\nexport function initializeObjectCache() {\n  for ( let definition of CacheableCategoryDefinitions ) {\n    MapCachesByCategory.set( definition.name, {\n      definition,\n      entries: new Map(),\n    })\n  }\n}\n\nasync function executeDiscard(\n  cacheKey: string,\n  discardFunction: Function,\n  objectPromise: Promise<Object>,\n) {\n  try {\n    await discardFunction( objectPromise )\n  } catch ( err ) {\n    const message = 'rb-base-server ObjectCache executeDiscard: failed'\n    log( 'error', message, { cacheKey, err })\n    throw new NestedError( message, err )\n  }\n}\n\nasync function cleanupCategory( cachedEntriesForCategory: CachedEntriesForCategory ) {\n  const { definition, entries } = cachedEntriesForCategory\n\n  // If the number if cached elements does not exceed max, no cleanup is necessary\n  if ( entries.size <= definition.countMax ) return\n\n  // Collect all the tics times\n  const arrCreatedTime: Array<number> = []\n  for ( let cachedEntry of entries.values() ) {\n    arrCreatedTime.push( cachedEntry.createdTimeMs )\n  }\n\n  // Descending sort - newest entries come first\n  arrCreatedTime.sort( ( a, b ) => b - a )\n\n  // Remove all entries that are older than cutoff time\n  const cutOffTimeMs = arrCreatedTime[definition.countMax - 1]\n  for ( let [ cacheKey, cachedEntry ] of entries.entries() ) {\n    if ( cachedEntry.createdTimeMs < cutOffTimeMs ) {\n      // Discard if necessary. Do not wait.\n      const discardFunction = definition.onDiscard\n      if ( discardFunction ) {\n        const objectPromise = cachedEntry.objectPromise\n        executeDiscard( cacheKey, discardFunction, await objectPromise )\n      }\n\n      // Remove from map of cached objects\n      entries.delete( cacheKey )\n    }\n  }\n}\n\nasync function removeExpired() {\n  if ( debugWriteToConsoleObjectCacheActivity ) logEntries( 'removeExpired - before' )\n\n  let bPerishableItemsLeft = false\n\n  const timeMsNow = new Date().getTime()\n\n  for ( let cachedEntriesForCategory of MapCachesByCategory.values() ) {\n    const { definition, entries } = cachedEntriesForCategory\n\n    // If there is no expiration for the category, skip\n    if ( !definition.expirationDurationMs ) continue\n\n    const discardFunction = definition.onDiscard\n\n    // Delete expired entries\n    for ( let [ cacheKey, cachedEntry ] of entries.entries() ) {\n      // $AssureFlow expiresAtMs will be present\n      if ( cachedEntry.expiresAtMs < timeMsNow ) {\n        // Discard if necessary. Do not wait.\n        if ( discardFunction ) {\n          const objectPromise = cachedEntry.objectPromise\n          executeDiscard( cacheKey, discardFunction, await objectPromise )\n        }\n\n        // Remove from map of cached objects\n        entries.delete( cacheKey )\n      } else bPerishableItemsLeft = true\n    }\n  }\n\n  // If there are no more perishable items, simply remove the timer\n  if ( !bPerishableItemsLeft ) {\n    // $AssureFlow expirationIntervalTimer is guaranteed to be set\n    clearInterval( expirationIntervalTimer )\n    expirationIntervalTimer = null\n  }\n\n  if ( debugWriteToConsoleObjectCacheActivity ) logEntries( 'removeExpired - after' )\n}\n\nexport async function addObjectToCache(\n  categoryName: string,\n  cacheKey: string,\n  objectPromise: Promise<Object>,\n) {\n  const cachedEntriesForCategory = MapCachesByCategory.get( categoryName )\n  if ( cachedEntriesForCategory == null )\n    throw new Error( 'addObjectToCache: can not find cacheable category ' + categoryName )\n\n  const { definition, entries } = cachedEntriesForCategory\n\n  const timeMsNow = new Date().getTime()\n\n  const cachedEntry: CachedEntry = {\n    createdTimeMs: timeMsNow,\n    validByTimeMs: timeMsNow + definition.validityDurationMs,\n    objectPromise,\n    validityVerificationPromise: null,\n    creationPromise: null,\n  }\n\n  if ( definition.expirationDurationMs ) {\n    // Only start timer when first object with expiration is added. No reason to run it before\n    // that.\n    if ( expirationIntervalTimer == null ) {\n      expirationIntervalTimer = setInterval( removeExpired, expirationCheckInterval )\n    }\n\n    cachedEntry.expiresAtMs = timeMsNow + definition.expirationDurationMs\n  }\n\n  entries.set( cacheKey, cachedEntry )\n\n  await cleanupCategory( cachedEntriesForCategory )\n\n  if ( debugWriteToConsoleObjectCacheActivity ) logEntries( 'addObjectToCache key=' + cacheKey )\n}\n\nexport async function getObjectFromCache( categoryName: string, cacheKey: string ): ?Object {\n  const cachedEntry = await getCachedEntryFromCache( categoryName, cacheKey )\n\n  if ( cachedEntry ) {\n    return await cachedEntry.objectPromise\n  } else {\n    return null\n  }\n}\n\nasync function getCachedEntryFromCache(\n  categoryName: string,\n  cacheKey: string,\n): Promise<?CachedEntry> {\n  const cachedEntriesForCategory = MapCachesByCategory.get( categoryName )\n  if ( cachedEntriesForCategory == null )\n    throw new Error( 'getCachedEntryFromCache: can not find cacheable category ' + categoryName )\n\n  const { definition, entries } = cachedEntriesForCategory\n  const cachedEntry = entries.get( cacheKey )\n\n  // Entry is not present in cache ?\n  if ( cachedEntry == null ) return null\n\n  const timeMsNow = new Date().getTime()\n\n  // Entry is in the cache\n  // If the entry already has expiration, increase it since it is used\n  if ( cachedEntry.expiresAtMs ) {\n    const cachedEntriesForCategory = MapCachesByCategory.get( categoryName )\n\n    // $AssureFlow our code is written in a way that definition would be present\n    const { definition } = cachedEntriesForCategory\n\n    cachedEntry.expiresAtMs = timeMsNow + definition.expirationDurationMs\n  }\n\n  if ( cachedEntry.validByTimeMs >= timeMsNow ) {\n    return cachedEntry\n  }\n\n  // Run the function to verify the validity of the cached entry, or wait for\n  // a validity verification function that's already running\n  let isValid: boolean = false\n  if ( cachedEntry.validityVerificationPromise == null ) {\n    try {\n      cachedEntry.validityVerificationPromise = definition.validityVerifier( cacheKey, cachedEntry )\n      isValid = await cachedEntry.validityVerificationPromise\n    } catch ( err ) {\n      // Indicate that the entry is invalid\n      cachedEntry.validityVerificationPromise = Promise.resolve( false )\n\n      // Record the problem and throw exception further\n      log(\n        'error',\n        'rb-base-server ObjectCache getCachedEntryFromCache: validityVerificationPromise failed',\n        { categoryName, cacheKey, err },\n      )\n      throw new NestedError( 'XXX', err )\n    }\n  }\n\n  cachedEntry.validityVerificationPromise = null\n  if ( isValid ) {\n    cachedEntry.validByTimeMs = timeMsNow + definition.validityDurationMs\n    return cachedEntry\n  } else {\n    // Entry is present in cache, but is invalid. Delete\n    entries.delete( cacheKey )\n    return new Promise( () => null )\n  }\n}\n\nexport async function getOrCreateObjectFromCahce(\n  categoryName: string,\n  cacheKey: string,\n  creationFunction: Function,\n): Object {\n  const currentCachedEntry = await getCachedEntryFromCache( categoryName, cacheKey )\n\n  // If it is already present in cache, return\n  if ( currentCachedEntry ) {\n    return await currentCachedEntry.objectPromise\n  }\n\n  // Not present in cache - create\n  let newObjectPromise\n  try {\n    newObjectPromise = creationFunction()\n  } catch ( err ) {\n    log( 'error', 'rb-base-server ObjectCache getOrCreateObjectFromCahce: creationFunction failed', {\n      categoryName,\n      cacheKey,\n      err,\n    })\n    throw new NestedError( 'XXX', err )\n  }\n\n  // Add the promise to the cache now, so that other requests to the cache\n  // for the same entry use the promise and do not kick off a second\n  // creation function\n  addObjectToCache( categoryName, cacheKey, newObjectPromise )\n\n  if ( debugWriteToConsoleObjectCacheActivity ) logEntries( 'getOrCreateObjectFromCahce' )\n\n  try {\n    return await newObjectPromise\n  } catch ( err ) {\n    log(\n      'error',\n      'rb-base-server ObjectCache getOrCreateObjectFromCahce: await creationFunction failed',\n      {\n        categoryName,\n        cacheKey,\n        err,\n      },\n    )\n\n    const cachedEntriesForCategory = MapCachesByCategory.get( categoryName )\n\n    // $AssureFlow it is guaranteed that the category exists\n    const { entries } = cachedEntriesForCategory\n    entries.delete( cacheKey )\n\n    throw new NestedError( 'XXX', err )\n  }\n}\n\nfunction logEntries( title: string ) {\n  const timeMsNow = new Date().getTime()\n  const values: Array<Object> = []\n\n  for ( let cachedEntriesForCategory of MapCachesByCategory.values() ) {\n    const { definition, entries } = cachedEntriesForCategory\n\n    // Delete expired entries\n    for ( let [ cacheKey, cachedEntry ] of entries.entries() ) {\n      const display = {\n        name: definition.name,\n        key: cacheKey,\n        validBy: cachedEntry.validByTimeMs,\n        validByLeft: cachedEntry.validByTimeMs - timeMsNow,\n        expires: 0,\n        expiresLeft: 0,\n      }\n\n      if ( cachedEntry.expiresAtMs ) {\n        display.expires = cachedEntry.expiresAtMs\n        display.expiresLeft = cachedEntry.expiresAtMs - timeMsNow\n      }\n\n      values.push( display )\n    }\n  }\n\n  console.log( title + ' @ ' + timeMsNow )\n  console.table( values )\n}\n"],"file":"ObjectCache.js"}