{"version":3,"sources":["../../../units/rb-base-server/ObjectCache.js"],"names":["expirationCheckInterval","expirationIntervalTimer","MapCachesByCategory","Map","initializeObjectCache","definition","CacheableCategoryDefinitions","set","name","entries","executeDiscard","cacheKey","discardFunction","objectPromise","err","message","NestedError","cleanupCategory","cachedEntriesForCategory","size","countMax","arrCreatedTime","cachedEntry","values","push","createdTimeMs","sort","a","b","cutOffTimeMs","onDiscard","delete","removeExpired","debugWriteToConsoleObjectCacheActivity","logEntries","bPerishableItemsLeft","timeMsNow","Date","getTime","expirationDurationMs","expiresAtMs","clearInterval","addObjectToCache","categoryName","get","Error","validByTimeMs","validityDurationMs","validityVerificationPromise","creationPromise","setInterval","getObjectFromCache","getCachedEntryFromCache","isValid","validityVerifier","Promise","resolve","getOrCreateObjectFromCahce","creationFunction","currentCachedEntry","newObjectPromise","title","display","key","validBy","validByLeft","expires","expiresLeft","console","log","table"],"mappings":"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","sourcesContent":["// @flow\n\nimport NestedError from 'nested-error-stacks'\n\nimport CacheableCategoryDefinitions from '../_configuration/rb-base-server/CacheableCategoryDefinitions'\nimport { debugWriteToConsoleObjectCacheActivity } from '../_configuration/debug'\n\nimport log from './log'\nimport type {\n  CachedEntriesForCategory,\n  CachedEntry\n} from './types/ObjectCache.types'\n\nconst expirationCheckInterval = 5000\nlet expirationIntervalTimer = null\n\nconst MapCachesByCategory: Map<string, CachedEntriesForCategory> = new Map()\n\nexport function initializeObjectCache() {\n  for (let definition of CacheableCategoryDefinitions) {\n    MapCachesByCategory.set(definition.name, {\n      definition,\n      entries: new Map()\n    })\n  }\n}\n\nasync function executeDiscard(\n  cacheKey: string,\n  discardFunction: Function,\n  objectPromise: Promise<Object>\n) {\n  try {\n    await discardFunction(objectPromise)\n  } catch (err) {\n    const message = 'rb-base-server ObjectCache executeDiscard: failed'\n    log('error', message, { cacheKey, err })\n    throw new NestedError(message, err)\n  }\n}\n\nasync function cleanupCategory(\n  cachedEntriesForCategory: CachedEntriesForCategory\n) {\n  const { definition, entries } = cachedEntriesForCategory\n\n  // If the number if cached elements does not exceed max, no cleanup is necessary\n  if (entries.size <= definition.countMax) return\n\n  // Collect all the tics times\n  const arrCreatedTime: Array<number> = []\n  for (let cachedEntry of entries.values()) {\n    arrCreatedTime.push(cachedEntry.createdTimeMs)\n  }\n\n  // Descending sort - newest entries come first\n  arrCreatedTime.sort((a, b) => b - a)\n\n  // Remove all entries that are older than cutoff time\n  const cutOffTimeMs = arrCreatedTime[definition.countMax - 1]\n  for (let [cacheKey, cachedEntry] of entries.entries()) {\n    if (cachedEntry.createdTimeMs < cutOffTimeMs) {\n      // Discard if necessary. Do not wait.\n      const discardFunction = definition.onDiscard\n      if (discardFunction) {\n        const objectPromise = cachedEntry.objectPromise\n        executeDiscard(cacheKey, discardFunction, await objectPromise)\n      }\n\n      // Remove from map of cached objects\n      entries.delete(cacheKey)\n    }\n  }\n}\n\nasync function removeExpired() {\n  if (debugWriteToConsoleObjectCacheActivity)\n    logEntries('removeExpired - before')\n\n  let bPerishableItemsLeft = false\n\n  const timeMsNow = new Date().getTime()\n\n  for (let cachedEntriesForCategory of MapCachesByCategory.values()) {\n    const { definition, entries } = cachedEntriesForCategory\n\n    // If there is no expiration for the category, skip\n    if (!definition.expirationDurationMs) continue\n\n    const discardFunction = definition.onDiscard\n\n    // Delete expired entries\n    for (let [cacheKey, cachedEntry] of entries.entries()) {\n      // $AssureFlow expiresAtMs will be present\n      if (cachedEntry.expiresAtMs < timeMsNow) {\n        // Discard if necessary. Do not wait.\n        if (discardFunction) {\n          const objectPromise = cachedEntry.objectPromise\n          executeDiscard(cacheKey, discardFunction, await objectPromise)\n        }\n\n        // Remove from map of cached objects\n        entries.delete(cacheKey)\n      } else bPerishableItemsLeft = true\n    }\n  }\n\n  // If there are no more perishable items, simply remove the timer\n  if (!bPerishableItemsLeft) {\n    clearInterval(expirationIntervalTimer)\n    expirationIntervalTimer = null\n  }\n\n  if (debugWriteToConsoleObjectCacheActivity)\n    logEntries('removeExpired - after')\n}\n\n/**\n * Adds an object to cache by category and cache key\n */\nexport async function addObjectToCache(\n  categoryName: string,\n  cacheKey: string,\n  objectPromise: Promise<Object>\n) {\n  const cachedEntriesForCategory = MapCachesByCategory.get(categoryName)\n  if (cachedEntriesForCategory == null)\n    throw new Error(\n      'addObjectToCache: can not find cacheable category ' + categoryName\n    )\n\n  const { definition, entries } = cachedEntriesForCategory\n\n  const timeMsNow = new Date().getTime()\n\n  const cachedEntry: CachedEntry = {\n    createdTimeMs: timeMsNow,\n    validByTimeMs: timeMsNow + definition.validityDurationMs,\n    objectPromise,\n    validityVerificationPromise: null,\n    creationPromise: null\n  }\n\n  if (definition.expirationDurationMs) {\n    // Only start timer when first object with expiration is added. No reason to run it before\n    // that.\n    if (expirationIntervalTimer == null) {\n      expirationIntervalTimer = setInterval(\n        removeExpired,\n        expirationCheckInterval\n      )\n    }\n\n    cachedEntry.expiresAtMs = timeMsNow + definition.expirationDurationMs\n  }\n\n  entries.set(cacheKey, cachedEntry)\n\n  await cleanupCategory(cachedEntriesForCategory)\n\n  if (debugWriteToConsoleObjectCacheActivity)\n    logEntries('addObjectToCache key=' + cacheKey)\n}\n\nexport async function getObjectFromCache(\n  categoryName: string,\n  cacheKey: string\n): ?Object {\n  const cachedEntry = await getCachedEntryFromCache(categoryName, cacheKey)\n\n  if (cachedEntry) {\n    return await cachedEntry.objectPromise\n  } else {\n    return null\n  }\n}\n\nasync function getCachedEntryFromCache(\n  categoryName: string,\n  cacheKey: string\n): Promise<?CachedEntry> {\n  const cachedEntriesForCategory = MapCachesByCategory.get(categoryName)\n  if (cachedEntriesForCategory == null)\n    throw new Error(\n      'getCachedEntryFromCache: can not find cacheable category ' + categoryName\n    )\n\n  const { definition, entries } = cachedEntriesForCategory\n  const cachedEntry = entries.get(cacheKey)\n\n  // Entry is not present in cache ?\n  if (cachedEntry == null) return null\n\n  const timeMsNow = new Date().getTime()\n\n  // Entry is in the cache\n  // If the entry already has expiration, increase it since it is used\n  if (cachedEntry.expiresAtMs) {\n    const cachedEntriesForCategory = MapCachesByCategory.get(categoryName)\n\n    // $AssureFlow our code is written in a way that definition would be present\n    const { definition } = cachedEntriesForCategory\n\n    cachedEntry.expiresAtMs = timeMsNow + definition.expirationDurationMs\n  }\n\n  if (cachedEntry.validByTimeMs >= timeMsNow) {\n    return cachedEntry\n  }\n\n  // Run the function to verify the validity of the cached entry, or wait for\n  // a validity verification function that's already running\n  let isValid: boolean = false\n  if (cachedEntry.validityVerificationPromise == null) {\n    try {\n      cachedEntry.validityVerificationPromise = definition.validityVerifier(\n        cacheKey,\n        cachedEntry\n      )\n      isValid = await cachedEntry.validityVerificationPromise\n    } catch (err) {\n      // Indicate that the entry is invalid\n      cachedEntry.validityVerificationPromise = Promise.resolve(false)\n\n      // Record the problem and throw exception further\n      const message =\n        'rb-base-server ObjectCache getCachedEntryFromCache: validityVerificationPromise failed'\n      log('error', message, { categoryName, cacheKey, err })\n      throw new NestedError(message, err)\n    }\n  }\n\n  cachedEntry.validityVerificationPromise = null\n  if (isValid) {\n    cachedEntry.validByTimeMs = timeMsNow + definition.validityDurationMs\n    return cachedEntry\n  } else {\n    // Entry is present in cache, but is invalid. Delete\n    entries.delete(cacheKey)\n    return new Promise(() => null)\n  }\n}\n\nexport async function getOrCreateObjectFromCahce(\n  categoryName: string,\n  cacheKey: string,\n  creationFunction: Function\n): Object {\n  const currentCachedEntry = await getCachedEntryFromCache(\n    categoryName,\n    cacheKey\n  )\n\n  // If it is already present in cache, return\n  if (currentCachedEntry) {\n    return await currentCachedEntry.objectPromise\n  }\n\n  // Not present in cache - create\n  let newObjectPromise\n  try {\n    newObjectPromise = creationFunction()\n  } catch (err) {\n    const message =\n      'rb-base-server ObjectCache getOrCreateObjectFromCahce: creationFunction failed'\n    log('error', message, { cacheKey, err })\n    throw new NestedError(message, err)\n  }\n\n  // Add the promise to the cache now, so that other requests to the cache\n  // for the same entry use the promise and do not kick off a second\n  // creation function\n  addObjectToCache(categoryName, cacheKey, newObjectPromise)\n\n  if (debugWriteToConsoleObjectCacheActivity)\n    logEntries('getOrCreateObjectFromCahce')\n\n  try {\n    return await newObjectPromise\n  } catch (err) {\n    const message =\n      'rb-base-server ObjectCache getOrCreateObjectFromCahce: await creationFunction failed'\n    log('error', message, { categoryName, cacheKey, err })\n\n    const cachedEntriesForCategory = MapCachesByCategory.get(categoryName)\n\n    // $AssureFlow it is guaranteed that the category exists\n    const { entries } = cachedEntriesForCategory\n    entries.delete(cacheKey)\n\n    throw new NestedError(message, err)\n  }\n}\n\nfunction logEntries(title: string) {\n  const timeMsNow = new Date().getTime()\n  const values: Array<Object> = []\n\n  for (let cachedEntriesForCategory of MapCachesByCategory.values()) {\n    const { definition, entries } = cachedEntriesForCategory\n\n    // Delete expired entries\n    for (let [cacheKey, cachedEntry] of entries.entries()) {\n      const display = {\n        name: definition.name,\n        key: cacheKey,\n        validBy: cachedEntry.validByTimeMs,\n        validByLeft: cachedEntry.validByTimeMs - timeMsNow,\n        expires: 0,\n        expiresLeft: 0\n      }\n\n      if (cachedEntry.expiresAtMs) {\n        display.expires = cachedEntry.expiresAtMs\n        display.expiresLeft = cachedEntry.expiresAtMs - timeMsNow\n      }\n\n      values.push(display)\n    }\n  }\n\n  console.log('XXX ' + title + ' @ ' + timeMsNow)\n  console.table(values)\n}\n"],"file":"ObjectCache.js"}