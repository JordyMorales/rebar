{"version":3,"sources":["../../../units/urb-base-server/ObjectCache.js"],"names":["initializeObjectCache","addObjectToCache","getObjectFromCache","getOrCreateObjectFromCahce","expirationCheckInterval","expirationIntervalTimer","MapCachesByCategory","Map","definition","CacheableCategoryDefinitions","set","name","entries","executeDiscard","cacheKey","discardFunction","objectPromise","err","log","source","cleanupCategory","cachedEntriesForCategory","size","countMax","arrCreatedTime","cachedEntry","values","push","createdTimeMs","sort","a","b","cutOffTimeMs","onDiscard","delete","removeExpired","debugWriteToConsoleObjectCacheActivity","logEntries","bPerishableItemsLeft","timeMsNow","Date","getTime","expirationDurationMs","expiresAtMs","clearInterval","categoryName","get","Error","validByTimeMs","validityDurationMs","validityVerificationPromise","creationPromise","setInterval","getCachedEntryFromCache","isValid","validityVerifier","Promise","resolve","creationFunction","currentCachedEntry","newObjectPromise","title","display","key","validBy","validByLeft","expires","expiresLeft","console","table"],"mappings":"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","file":"ObjectCache.js","sourcesContent":["// @flow\n\nimport CacheableCategoryDefinitions from '../_configuration/urb-base-server/CacheableCategoryDefinitions'\nimport { debugWriteToConsoleObjectCacheActivity } from '../_configuration/debug'\n\nimport log from './log'\nimport type { CachedEntriesForCategory, CachedEntry } from './types/ObjectCache.types'\n\nconst expirationCheckInterval = 5000\nlet expirationIntervalTimer = null\n\nconst MapCachesByCategory: Map<string, CachedEntriesForCategory> = new Map()\n\nexport function initializeObjectCache() {\n  for ( let definition of CacheableCategoryDefinitions ) {\n    MapCachesByCategory.set( definition.name, {\n      definition,\n      entries: new Map(),\n    })\n  }\n}\n\nasync function executeDiscard(\n  cacheKey: string,\n  discardFunction: Function,\n  objectPromise: Promise<Object>,\n) {\n  try {\n    await discardFunction( objectPromise )\n  } catch ( err ) {\n    // Record the problem and throw exception further\n    log.log( 'error', {\n      source: 'executeDiscard failed',\n      cacheKey,\n      err,\n    })\n  }\n}\n\nasync function cleanupCategory( cachedEntriesForCategory: CachedEntriesForCategory ) {\n  const { definition, entries } = cachedEntriesForCategory\n\n  // If the number if cached elements does not exceed max, no cleanup is necessary\n  if ( entries.size <= definition.countMax ) return\n\n  // Collect all the tics times\n  const arrCreatedTime: Array<number> = []\n  for ( let cachedEntry of entries.values() ) {\n    arrCreatedTime.push( cachedEntry.createdTimeMs )\n  }\n\n  // Descending sort - newest entries come first\n  arrCreatedTime.sort( ( a, b ) => b - a )\n\n  // Remove all entries that are older than cutoff time\n  const cutOffTimeMs = arrCreatedTime[definition.countMax - 1]\n  for ( let [ cacheKey, cachedEntry ] of entries.entries() ) {\n    if ( cachedEntry.createdTimeMs < cutOffTimeMs ) {\n      // Discard if necessary. Do not wait.\n      const discardFunction = definition.onDiscard\n      if ( discardFunction ) {\n        const objectPromise = cachedEntry.objectPromise\n        executeDiscard( cacheKey, discardFunction, await objectPromise )\n      }\n\n      // Remove from map of cached objects\n      entries.delete( cacheKey )\n    }\n  }\n}\n\nasync function removeExpired() {\n  if ( debugWriteToConsoleObjectCacheActivity ) logEntries( 'removeExpired - before' )\n\n  let bPerishableItemsLeft = false\n\n  const timeMsNow = new Date().getTime()\n\n  for ( let cachedEntriesForCategory of MapCachesByCategory.values() ) {\n    const { definition, entries } = cachedEntriesForCategory\n\n    // If there is no expiration for the category, skip\n    if ( !definition.expirationDurationMs ) continue\n\n    const discardFunction = definition.onDiscard\n\n    // Delete expired entries\n    for ( let [ cacheKey, cachedEntry ] of entries.entries() ) {\n      // $AssureFlow expiresAtMs will be present\n      if ( cachedEntry.expiresAtMs < timeMsNow ) {\n        // Discard if necessary. Do not wait.\n        if ( discardFunction ) {\n          const objectPromise = cachedEntry.objectPromise\n          executeDiscard( cacheKey, discardFunction, await objectPromise )\n        }\n\n        // Remove from map of cached objects\n        entries.delete( cacheKey )\n      } else bPerishableItemsLeft = true\n    }\n  }\n\n  // If there are no more perishable items, simply remove the timer\n  if ( !bPerishableItemsLeft ) {\n    // $AssureFlow expirationIntervalTimer is guaranteed to be set\n    clearInterval( expirationIntervalTimer )\n    expirationIntervalTimer = null\n  }\n\n  if ( debugWriteToConsoleObjectCacheActivity ) logEntries( 'removeExpired - after' )\n}\n\nexport async function addObjectToCache(\n  categoryName: string,\n  cacheKey: string,\n  objectPromise: Promise<Object>,\n) {\n  const cachedEntriesForCategory = MapCachesByCategory.get( categoryName )\n  if ( cachedEntriesForCategory == null )\n    throw new Error( 'addObjectToCache: can not find cacheable category ' + categoryName )\n\n  const { definition, entries } = cachedEntriesForCategory\n\n  const timeMsNow = new Date().getTime()\n\n  const cachedEntry: CachedEntry = {\n    createdTimeMs: timeMsNow,\n    validByTimeMs: timeMsNow + definition.validityDurationMs,\n    objectPromise,\n    validityVerificationPromise: null,\n    creationPromise: null,\n  }\n\n  if ( definition.expirationDurationMs ) {\n    // Only start timer when first object with expiration is added. No reason to run it before\n    // that.\n    if ( expirationIntervalTimer == null ) {\n      expirationIntervalTimer = setInterval( removeExpired, expirationCheckInterval )\n    }\n\n    cachedEntry.expiresAtMs = timeMsNow + definition.expirationDurationMs\n  }\n\n  entries.set( cacheKey, cachedEntry )\n\n  await cleanupCategory( cachedEntriesForCategory )\n\n  if ( debugWriteToConsoleObjectCacheActivity ) logEntries( 'addObjectToCache key=' + cacheKey )\n}\n\nexport async function getObjectFromCache( categoryName: string, cacheKey: string ): ?Object {\n  const cachedEntry = await getCachedEntryFromCache( categoryName, cacheKey )\n\n  if ( cachedEntry ) {\n    return await cachedEntry.objectPromise\n  } else {\n    return null\n  }\n}\n\nasync function getCachedEntryFromCache(\n  categoryName: string,\n  cacheKey: string,\n): Promise<?CachedEntry> {\n  const cachedEntriesForCategory = MapCachesByCategory.get( categoryName )\n  if ( cachedEntriesForCategory == null )\n    throw new Error( 'getCachedEntryFromCache: can not find cacheable category ' + categoryName )\n\n  const { definition, entries } = cachedEntriesForCategory\n  const cachedEntry = entries.get( cacheKey )\n\n  // Entry is not present in cache ?\n  if ( cachedEntry == null ) return null\n\n  const timeMsNow = new Date().getTime()\n\n  // Entry is in the cache\n  // If the entry already has expiration, increase it since it is used\n  if ( cachedEntry.expiresAtMs ) {\n    const cachedEntriesForCategory = MapCachesByCategory.get( categoryName )\n\n    // $AssureFlow our code is written in a way that definition would be present\n    const { definition } = cachedEntriesForCategory\n\n    cachedEntry.expiresAtMs = timeMsNow + definition.expirationDurationMs\n  }\n\n  if ( cachedEntry.validByTimeMs >= timeMsNow ) {\n    return cachedEntry\n  }\n\n  // Run the function to verify the validity of the cached entry, or wait for\n  // a validity verification function that's already running\n  let isValid: boolean = false\n  if ( cachedEntry.validityVerificationPromise == null ) {\n    try {\n      cachedEntry.validityVerificationPromise = definition.validityVerifier( cacheKey, cachedEntry )\n      isValid = await cachedEntry.validityVerificationPromise\n    } catch ( err ) {\n      // Indicate that the entry is invalid\n      cachedEntry.validityVerificationPromise = Promise.resolve( false )\n\n      // Record the problem and throw exception further\n      log.log( 'error', {\n        source: 'getCachedEntryFromCache: validityVerificationPromise failed',\n        categoryName,\n        cacheKey,\n        err,\n      })\n      throw err\n    }\n  }\n\n  cachedEntry.validityVerificationPromise = null\n  if ( isValid ) {\n    cachedEntry.validByTimeMs = timeMsNow + definition.validityDurationMs\n    return cachedEntry\n  } else {\n    // Entry is present in cache, but is invalid. Delete\n    entries.delete( cacheKey )\n    return new Promise( () => null )\n  }\n}\n\nexport async function getOrCreateObjectFromCahce(\n  categoryName: string,\n  cacheKey: string,\n  creationFunction: Function,\n): Object {\n  const currentCachedEntry = await getCachedEntryFromCache( categoryName, cacheKey )\n\n  // If it is already present in cache, return\n  if ( currentCachedEntry ) {\n    return await currentCachedEntry.objectPromise\n  }\n\n  // Not present in cache - create\n  let newObjectPromise\n  try {\n    newObjectPromise = creationFunction()\n  } catch ( err ) {\n    log.log( 'error', {\n      source: 'getOrCreateObjectFromCahce: creationFunction failed',\n      categoryName,\n      cacheKey,\n      err,\n    })\n    throw err\n  }\n\n  // Add the promise to the cache now, so that other requests to the cache\n  // for the same entry use the promise and do not kick off a second\n  // creation function\n  addObjectToCache( categoryName, cacheKey, newObjectPromise )\n\n  if ( debugWriteToConsoleObjectCacheActivity ) logEntries( 'getOrCreateObjectFromCahce' )\n\n  try {\n    return await newObjectPromise\n  } catch ( err ) {\n    log.log( 'error', {\n      source: 'getOrCreateObjectFromCahce: await creationFunction failed',\n      categoryName,\n      cacheKey,\n      err,\n    })\n\n    const cachedEntriesForCategory = MapCachesByCategory.get( categoryName )\n\n    // $AssureFlow it is guaranteed that the category exists\n    const { entries } = cachedEntriesForCategory\n    entries.delete( cacheKey )\n\n    throw err\n  }\n}\n\nfunction logEntries( title: string ) {\n  const timeMsNow = new Date().getTime()\n  const values: Array<Object> = []\n\n  for ( let cachedEntriesForCategory of MapCachesByCategory.values() ) {\n    const { definition, entries } = cachedEntriesForCategory\n\n    // Delete expired entries\n    for ( let [ cacheKey, cachedEntry ] of entries.entries() ) {\n      const display = {\n        name: definition.name,\n        key: cacheKey,\n        validBy: cachedEntry.validByTimeMs,\n        validByLeft: cachedEntry.validByTimeMs - timeMsNow,\n        expires: 0,\n        expiresLeft: 0,\n      }\n\n      if ( cachedEntry.expiresAtMs ) {\n        display.expires = cachedEntry.expiresAtMs\n        display.expiresLeft = cachedEntry.expiresAtMs - timeMsNow\n      }\n\n      values.push( display )\n    }\n  }\n\n  console.log( title + ' @ ' + timeMsNow )\n  console.table( values )\n}\n"]}