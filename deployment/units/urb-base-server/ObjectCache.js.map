{"version":3,"sources":["../../../units/urb-base-server/ObjectCache.js"],"names":["expirationCheckInterval","expirationIntervalTimer","MapCachesByCategory","Map","initializeObjectCache","definition","CacheableCategoryDefinitions","set","name","entries","executeDiscard","cacheKey","discardFunction","objectPromise","err","log","level","message","details","cleanupCategory","cachedEntriesForCategory","size","countMax","arrCreatedTime","cachedEntry","values","push","createdTimeMs","sort","a","b","cutOffTimeMs","onDiscard","delete","removeExpired","debugWriteToConsoleObjectCacheActivity","logEntries","bPerishableItemsLeft","timeMsNow","Date","getTime","expirationDurationMs","expiresAtMs","clearInterval","addObjectToCache","categoryName","get","Error","validByTimeMs","validityDurationMs","validityVerificationPromise","creationPromise","setInterval","getObjectFromCache","getCachedEntryFromCache","isValid","validityVerifier","Promise","resolve","getOrCreateObjectFromCahce","creationFunction","currentCachedEntry","newObjectPromise","title","display","key","validBy","validByLeft","expires","expiresLeft","console","table"],"mappings":"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","sourcesContent":["// @flow\n\nimport CacheableCategoryDefinitions from '../_configuration/urb-base-server/CacheableCategoryDefinitions'\nimport { debugWriteToConsoleObjectCacheActivity } from '../_configuration/debug'\n\nimport log from './log'\nimport type { CachedEntriesForCategory, CachedEntry } from './types/ObjectCache.types'\n\nconst expirationCheckInterval = 5000\nlet expirationIntervalTimer = null\n\nconst MapCachesByCategory: Map<string, CachedEntriesForCategory> = new Map()\n\nexport function initializeObjectCache() {\n  for ( let definition of CacheableCategoryDefinitions ) {\n    MapCachesByCategory.set( definition.name, {\n      definition,\n      entries: new Map(),\n    })\n  }\n}\n\nasync function executeDiscard(\n  cacheKey: string,\n  discardFunction: Function,\n  objectPromise: Promise<Object>,\n) {\n  try {\n    await discardFunction( objectPromise )\n  } catch ( err ) {\n    // Record the problem and throw exception further\n    log.log({\n      level: 'error',\n      message: 'executeDiscard failed',\n      details: {\n        cacheKey,\n        err,\n      },\n    })\n  }\n}\n\nasync function cleanupCategory( cachedEntriesForCategory: CachedEntriesForCategory ) {\n  const { definition, entries } = cachedEntriesForCategory\n\n  // If the number if cached elements does not exceed max, no cleanup is necessary\n  if ( entries.size <= definition.countMax ) return\n\n  // Collect all the tics times\n  const arrCreatedTime: Array<number> = []\n  for ( let cachedEntry of entries.values() ) {\n    arrCreatedTime.push( cachedEntry.createdTimeMs )\n  }\n\n  // Descending sort - newest entries come first\n  arrCreatedTime.sort( ( a, b ) => b - a )\n\n  // Remove all entries that are older than cutoff time\n  const cutOffTimeMs = arrCreatedTime[definition.countMax - 1]\n  for ( let [ cacheKey, cachedEntry ] of entries.entries() ) {\n    if ( cachedEntry.createdTimeMs < cutOffTimeMs ) {\n      // Discard if necessary. Do not wait.\n      const discardFunction = definition.onDiscard\n      if ( discardFunction ) {\n        const objectPromise = cachedEntry.objectPromise\n        executeDiscard( cacheKey, discardFunction, await objectPromise )\n      }\n\n      // Remove from map of cached objects\n      entries.delete( cacheKey )\n    }\n  }\n}\n\nasync function removeExpired() {\n  if ( debugWriteToConsoleObjectCacheActivity ) logEntries( 'removeExpired - before' )\n\n  let bPerishableItemsLeft = false\n\n  const timeMsNow = new Date().getTime()\n\n  for ( let cachedEntriesForCategory of MapCachesByCategory.values() ) {\n    const { definition, entries } = cachedEntriesForCategory\n\n    // If there is no expiration for the category, skip\n    if ( !definition.expirationDurationMs ) continue\n\n    const discardFunction = definition.onDiscard\n\n    // Delete expired entries\n    for ( let [ cacheKey, cachedEntry ] of entries.entries() ) {\n      // $AssureFlow expiresAtMs will be present\n      if ( cachedEntry.expiresAtMs < timeMsNow ) {\n        // Discard if necessary. Do not wait.\n        if ( discardFunction ) {\n          const objectPromise = cachedEntry.objectPromise\n          executeDiscard( cacheKey, discardFunction, await objectPromise )\n        }\n\n        // Remove from map of cached objects\n        entries.delete( cacheKey )\n      } else bPerishableItemsLeft = true\n    }\n  }\n\n  // If there are no more perishable items, simply remove the timer\n  if ( !bPerishableItemsLeft ) {\n    // $AssureFlow expirationIntervalTimer is guaranteed to be set\n    clearInterval( expirationIntervalTimer )\n    expirationIntervalTimer = null\n  }\n\n  if ( debugWriteToConsoleObjectCacheActivity ) logEntries( 'removeExpired - after' )\n}\n\nexport async function addObjectToCache(\n  categoryName: string,\n  cacheKey: string,\n  objectPromise: Promise<Object>,\n) {\n  const cachedEntriesForCategory = MapCachesByCategory.get( categoryName )\n  if ( cachedEntriesForCategory == null )\n    throw new Error( 'addObjectToCache: can not find cacheable category ' + categoryName )\n\n  const { definition, entries } = cachedEntriesForCategory\n\n  const timeMsNow = new Date().getTime()\n\n  const cachedEntry: CachedEntry = {\n    createdTimeMs: timeMsNow,\n    validByTimeMs: timeMsNow + definition.validityDurationMs,\n    objectPromise,\n    validityVerificationPromise: null,\n    creationPromise: null,\n  }\n\n  if ( definition.expirationDurationMs ) {\n    // Only start timer when first object with expiration is added. No reason to run it before\n    // that.\n    if ( expirationIntervalTimer == null ) {\n      expirationIntervalTimer = setInterval( removeExpired, expirationCheckInterval )\n    }\n\n    cachedEntry.expiresAtMs = timeMsNow + definition.expirationDurationMs\n  }\n\n  entries.set( cacheKey, cachedEntry )\n\n  await cleanupCategory( cachedEntriesForCategory )\n\n  if ( debugWriteToConsoleObjectCacheActivity ) logEntries( 'addObjectToCache key=' + cacheKey )\n}\n\nexport async function getObjectFromCache( categoryName: string, cacheKey: string ): ?Object {\n  const cachedEntry = await getCachedEntryFromCache( categoryName, cacheKey )\n\n  if ( cachedEntry ) {\n    return await cachedEntry.objectPromise\n  } else {\n    return null\n  }\n}\n\nasync function getCachedEntryFromCache(\n  categoryName: string,\n  cacheKey: string,\n): Promise<?CachedEntry> {\n  const cachedEntriesForCategory = MapCachesByCategory.get( categoryName )\n  if ( cachedEntriesForCategory == null )\n    throw new Error( 'getCachedEntryFromCache: can not find cacheable category ' + categoryName )\n\n  const { definition, entries } = cachedEntriesForCategory\n  const cachedEntry = entries.get( cacheKey )\n\n  // Entry is not present in cache ?\n  if ( cachedEntry == null ) return null\n\n  const timeMsNow = new Date().getTime()\n\n  // Entry is in the cache\n  // If the entry already has expiration, increase it since it is used\n  if ( cachedEntry.expiresAtMs ) {\n    const cachedEntriesForCategory = MapCachesByCategory.get( categoryName )\n\n    // $AssureFlow our code is written in a way that definition would be present\n    const { definition } = cachedEntriesForCategory\n\n    cachedEntry.expiresAtMs = timeMsNow + definition.expirationDurationMs\n  }\n\n  if ( cachedEntry.validByTimeMs >= timeMsNow ) {\n    return cachedEntry\n  }\n\n  // Run the function to verify the validity of the cached entry, or wait for\n  // a validity verification function that's already running\n  let isValid: boolean = false\n  if ( cachedEntry.validityVerificationPromise == null ) {\n    try {\n      cachedEntry.validityVerificationPromise = definition.validityVerifier( cacheKey, cachedEntry )\n      isValid = await cachedEntry.validityVerificationPromise\n    } catch ( err ) {\n      // Indicate that the entry is invalid\n      cachedEntry.validityVerificationPromise = Promise.resolve( false )\n\n      // Record the problem and throw exception further\n      log.log({\n        level: 'error',\n        message: 'getCachedEntryFromCache: validityVerificationPromise failed',\n        details: {\n          categoryName,\n          cacheKey,\n          err,\n        },\n      })\n      throw err\n    }\n  }\n\n  cachedEntry.validityVerificationPromise = null\n  if ( isValid ) {\n    cachedEntry.validByTimeMs = timeMsNow + definition.validityDurationMs\n    return cachedEntry\n  } else {\n    // Entry is present in cache, but is invalid. Delete\n    entries.delete( cacheKey )\n    return new Promise( () => null )\n  }\n}\n\nexport async function getOrCreateObjectFromCahce(\n  categoryName: string,\n  cacheKey: string,\n  creationFunction: Function,\n): Object {\n  const currentCachedEntry = await getCachedEntryFromCache( categoryName, cacheKey )\n\n  // If it is already present in cache, return\n  if ( currentCachedEntry ) {\n    return await currentCachedEntry.objectPromise\n  }\n\n  // Not present in cache - create\n  let newObjectPromise\n  try {\n    newObjectPromise = creationFunction()\n  } catch ( err ) {\n    log.log({\n      level: 'error',\n      message: 'getOrCreateObjectFromCahce: creationFunction failed',\n      details: {\n        categoryName,\n        cacheKey,\n        err,\n      },\n    })\n    throw err\n  }\n\n  // Add the promise to the cache now, so that other requests to the cache\n  // for the same entry use the promise and do not kick off a second\n  // creation function\n  addObjectToCache( categoryName, cacheKey, newObjectPromise )\n\n  if ( debugWriteToConsoleObjectCacheActivity ) logEntries( 'getOrCreateObjectFromCahce' )\n\n  try {\n    return await newObjectPromise\n  } catch ( err ) {\n    log.log({\n      level: 'error',\n      message: 'getOrCreateObjectFromCahce: await creationFunction failed',\n      details: {\n        categoryName,\n        cacheKey,\n        err,\n      },\n    })\n\n    const cachedEntriesForCategory = MapCachesByCategory.get( categoryName )\n\n    // $AssureFlow it is guaranteed that the category exists\n    const { entries } = cachedEntriesForCategory\n    entries.delete( cacheKey )\n\n    throw err\n  }\n}\n\nfunction logEntries( title: string ) {\n  const timeMsNow = new Date().getTime()\n  const values: Array<Object> = []\n\n  for ( let cachedEntriesForCategory of MapCachesByCategory.values() ) {\n    const { definition, entries } = cachedEntriesForCategory\n\n    // Delete expired entries\n    for ( let [ cacheKey, cachedEntry ] of entries.entries() ) {\n      const display = {\n        name: definition.name,\n        key: cacheKey,\n        validBy: cachedEntry.validByTimeMs,\n        validByLeft: cachedEntry.validByTimeMs - timeMsNow,\n        expires: 0,\n        expiresLeft: 0,\n      }\n\n      if ( cachedEntry.expiresAtMs ) {\n        display.expires = cachedEntry.expiresAtMs\n        display.expiresLeft = cachedEntry.expiresAtMs - timeMsNow\n      }\n\n      values.push( display )\n    }\n  }\n\n  console.log( title + ' @ ' + timeMsNow )\n  console.table( values )\n}\n"],"file":"ObjectCache.js"}