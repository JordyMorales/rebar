{"version":3,"sources":["../../../units/rb-base-universal/template.js"],"names":["stringToTokenArray","source","result","accumulated","c","length","push","word","text","toLowerCase","symbol","matchObject","token","condition","inCondition","templTag_in","inConditionOption","Array","isArray","templateInfo","templTag_arr","matchArray","match","ix","tokenValue","conditionValue","templTag_notNull","templTag_isNull","typeOfValue","typeOfCondition","arrTokens","template","float","variables","tryMatchWhole","matchArrayPiece","ixTokens","ixStart","ixStop","lenPayload","tryMatchPart","arrTemplate","ixTemplate","lengthTokens","lengthTemplate","arrRepOptions","templTag_arrRep","min","elementTemplate","arrOrOptions","templTag_arrOr","arrVarOptions","templTag_arrVar","bOptionMatchFound","orOption","optionMatch","items","max","found","name","variableMatch","ixTokensStart","slice","elementPayload","replaceMatchInArray","matchInfo","arrBefore","arrAfter","arrReplacements","element","optionsReplArr","templTag_replArr","variable","arrVariableValue","variableElement","replaceReplObj","concat","optionsReplObj","templTag_replObj","path","variableValue","retrieveObjectAtPath","propName","matchAndReplace","arrReplacement"],"mappings":";;AAEA;;;;;;;;;;;;AAYO,SAASA,kBAAT,CAA4BC,MAA5B,EAA4C;AACjD,QAAMC,MAAM,GAAG,EAAf;;AAEA,MAAIC,WAAW,GAAG,EAAlB;AACA,OAAK,IAAIC,CAAT,IAAcH,MAAd,EAAsB;AACpB;AACGG,IAAAA,CAAC,IAAI,GAAL,IAAYA,CAAC,IAAI,GAAlB;AACCA,IAAAA,CAAC,IAAI,GAAL,IAAYA,CAAC,IAAI,GADlB;AAECA,IAAAA,CAAC,IAAI,GAAL,IAAYA,CAAC,IAAI,GAHpB;AAIE;AACAD,MAAAA,WAAW,IAAIC,CAAf;AACD,KAND,MAMO;AACL,UAAID,WAAW,CAACE,MAAZ,GAAqB,CAAzB,EAA4B;AAC1BH,QAAAA,MAAM,CAACI,IAAP,CAAY,EAAEC,IAAI,EAAE,EAAEC,IAAI,EAAEL,WAAW,CAACM,WAAZ,EAAR,EAAR,EAAZ;AACAN,QAAAA,WAAW,GAAG,EAAd;AACD;AACD,UAAIC,CAAC,KAAK,GAAV,EAAe;AACbF,QAAAA,MAAM,CAACI,IAAP,CAAY,EAAEI,MAAM,EAAE,EAAEF,IAAI,EAAEJ,CAAR,EAAV,EAAZ;AACD;AACF;AACF;;AAED,MAAID,WAAW,CAACE,MAAZ,GAAqB,CAAzB,EAA4B;AAC1BH,IAAAA,MAAM,CAACI,IAAP,CAAY,EAAEC,IAAI,EAAE,EAAEC,IAAI,EAAEL,WAAW,CAACM,WAAZ,EAAR,EAAR,EAAZ;AACAN,IAAAA,WAAW,GAAG,EAAd;AACD;;AAED,SAAOD,MAAP;AACD;;AAEM,SAASS,WAAT,CAAqBC,KAArB,EAAiCC,SAAjC,EAA0D;AAC/D;AACE,SAAOA,SAAP,KAAqB,QAArB;AACA,SAAOA,SAAP,KAAqB,QADrB;AAEA,SAAOA,SAAP,KAAqB,SAHvB;AAIE;AACA,WAAOD,KAAK,KAAKC,SAAjB;AACD;;AAED;AACA,MAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AACjC,UAAMC,WAAW,GAAGD,SAAS,CAACE,yBAAD,CAA7B;;AAEA,QAAID,WAAJ,EAAiB;AACf;AACA,WAAK,IAAIE,iBAAT,IAA8BF,WAA9B,EAA2C;AACzC,YAAIH,WAAW,CAACC,KAAD,EAAQI,iBAAR,CAAf,EAA2C;AACzC,iBAAO,IAAP;AACD;AACF;AACF;;AAED;AACA,QAAIC,KAAK,CAACC,OAAN,CAAcN,KAAd,CAAJ,EAA0B;AACxB;AACA,UAAI,CAACK,KAAK,CAACC,OAAN,CAAcL,SAAd,CAAL,EAA+B;AAC7B,cAAMM,YAAY,GAAGN,SAAS,CAACO,0BAAD,CAA9B;;AAEA,YAAID,YAAJ,EAAkB;AAChB,iBAAOE,UAAU,CAACT,KAAD,EAAQO,YAAR,CAAV,CAAgCG,KAAvC;AACD,SAFD,MAEO;AACL,iBAAO,KAAP;AACD;AACF;;AAED;AACA,UAAIV,KAAK,CAACP,MAAN,KAAiBQ,SAAS,CAACR,MAA/B,EAAuC;AACrC,eAAO,KAAP;AACD;AACF,KA7BgC,CA6B/B;;AAEF,SAAK,IAAIkB,EAAT,IAAeV,SAAf,EAA0B;AACxB,YAAMW,UAAU,GAAGZ,KAAK,CAACW,EAAD,CAAxB;AACA,YAAME,cAAc,GAAGZ,SAAS,CAACU,EAAD,CAAhC;;AAEA,UAAIE,cAAc,KAAKC,8BAAvB,EAAyC;AACvC,YAAIF,UAAU,IAAI,IAAlB,EAAwB;AACtB,iBAAO,KAAP;AACD,SAFD,MAEO;AACL;AACD;AACF;AACD,UAAIC,cAAc,KAAKE,6BAAvB,EAAwC;AACtC,YAAIH,UAAU,IAAI,IAAlB,EAAwB;AACtB,iBAAO,KAAP;AACD,SAFD,MAEO;AACL;AACD;AACF;;AAED,YAAMI,WAAW,GAAG,OAAOJ,UAA3B;AACA,YAAMK,eAAe,GAAG,OAAOJ,cAA/B;;AAEA,UAAII,eAAe,KAAK,QAAxB,EAAkC;AAChC;;AAEA,YAAID,WAAW,KAAKC,eAApB,EAAqC;AACnC,iBAAO,KAAP;AACD;AACD,YAAI,CAAClB,WAAW,CAACa,UAAD,EAAaC,cAAb,CAAhB,EAA8C;AAC5C,iBAAO,KAAP;AACD;AACF,OATD,MASO;AACL,YAAID,UAAU,KAAKC,cAAnB,EAAmC;AACjC,iBAAO,KAAP;AACD;AACF,OAnCuB,CAmCtB;AACH,KAnEgC,CAmE/B;AACH,GA9E8D,CA8E7D;;AAEF,SAAO,IAAP;AACD;;AAEM,SAASJ,UAAT;AACLS,SADK;AAELX,YAFK;;;;;;;;AAUD;AACJ,QAAM,EAAEY,QAAF,EAAYC,KAAZ,KAAsBb,YAA5B;;AAEA,QAAMc,SAA4B,GAAG,EAArC;;AAEA,MAAI,CAACD,KAAL,EAAY;AACV,UAAME,aAAa,GAAGC,eAAe,CAACL,SAAD,EAAYC,QAAZ,EAAsB,CAAtB,EAAyB,CAAzB,EAA4BE,SAA5B,CAArC;;AAEA,QAAI,CAACC,aAAa,CAACZ,KAAnB,EAA0B;AACxB,aAAO,EAAEA,KAAK,EAAE,KAAT,EAAP;AACD,KAFD,MAEO,IAAIY,aAAa,CAACE,QAAd,KAA2BN,SAAS,CAACzB,MAAzC,EAAiD;AACtD,aAAO;AACLgC,QAAAA,OAAO,EAAE,CADJ;AAELC,QAAAA,MAAM,EAAER,SAAS,CAACzB,MAAV,GAAmB,CAFtB;AAGLiB,QAAAA,KAAK,EAAE,IAHF;AAILW,QAAAA,SAJK,EAAP;;AAMD,KAPM,MAOA;AACL,aAAO,EAAEX,KAAK,EAAE,KAAT,EAAP;AACD;AACF,GAfD,MAeO;AACL,UAAMiB,UAAU,GAAGT,SAAS,CAACzB,MAA7B;;AAEA,SAAK,IAAIgC,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGE,UAAhC,EAA4CF,OAAO,EAAnD,EAAuD;AACrD,YAAMG,YAAY,GAAGL,eAAe;AAClCL,MAAAA,SADkC;AAElCC,MAAAA,QAFkC;AAGlCM,MAAAA,OAHkC;AAIlC,OAJkC;AAKlCJ,MAAAA,SALkC,CAApC;;;AAQA,UAAIO,YAAY,CAAClB,KAAjB,EAAwB;AACtB,eAAO;AACLe,UAAAA,OADK;AAELC,UAAAA,MAAM,EAAEE,YAAY,CAACJ,QAAb,GAAwB,CAF3B;AAGLd,UAAAA,KAAK,EAAE,IAHF;AAILW,UAAAA,SAJK,EAAP;;AAMD;AACF;;AAED;AACA,WAAO,EAAEX,KAAK,EAAE,KAAT,EAAP;AACD;AACF;;AAED,SAASa,eAAT;AACEL,SADF;AAEEW,WAFF;AAGEL,QAHF;AAIEM,UAJF;AAKET,SALF;AAM4E;AAC1E,QAAMU,YAAY,GAAGb,SAAS,CAACzB,MAA/B;AACA,QAAMuC,cAAc,GAAGH,WAAW,CAACpC,MAAnC;;AAEA,WAAS;AACP;AACA,QAAIqC,UAAU,IAAIE,cAAlB,EAAkC;AAChC,aAAO,EAAEtB,KAAK,EAAE,IAAT,EAAec,QAAf,EAAyBM,UAAzB,EAAP;AACD;;AAED;AACA,QAAIN,QAAQ,IAAIO,YAAhB,EAA8B;AAC5B;AACA;AACA;AACA,aAAOD,UAAU,GAAGE,cAApB,EAAoCF,UAAU,EAA9C,EAAkD;AAChD,cAAMG,aAAa,GAAGJ,WAAW,CAACC,UAAD,CAAX,CAAwBI,6BAAxB,CAAtB;;AAEA,YAAID,aAAa,IAAIA,aAAa,CAACE,GAAd,KAAsB,CAA3C,EAA8C,SAA9C;AACK;AACN;;AAED;AACA,UAAIL,UAAU,IAAIE,cAAlB,EAAkC;AAChC,eAAO,EAAEtB,KAAK,EAAE,IAAT,EAAec,QAAf,EAAyBM,UAAzB,EAAP;AACD;;AAED,aAAO,EAAEpB,KAAK,EAAE,KAAT,EAAP;AACD;;AAED,UAAM0B,eAAe,GAAGP,WAAW,CAACC,UAAD,CAAnC;AACA,UAAMO,YAAY,GAAGD,eAAe,CAACE,4BAAD,CAApC;AACA,UAAML,aAAa,GAAGG,eAAe,CAACF,6BAAD,CAArC;AACA,UAAMK,aAAa,GAAGH,eAAe,CAACI,6BAAD,CAArC;;AAEA,QAAIH,YAAJ,EAAkB;AAChB,UAAII,iBAAiB,GAAG,KAAxB;AACA,WAAK,IAAIC,QAAT,IAAqBL,YAArB,EAAmC;AACjC,cAAMM,WAAW,GAAGpB,eAAe;AACjCL,QAAAA,SADiC;AAEjCwB,QAAAA,QAFiC;AAGjClB,QAAAA,QAHiC;AAIjC,SAJiC;AAKjCH,QAAAA,SALiC,CAAnC;;;AAQA,YAAIsB,WAAW,CAACjC,KAAhB,EAAuB;AACrB+B,UAAAA,iBAAiB,GAAG,IAApB;;AAEAjB,UAAAA,QAAQ,GAAGmB,WAAW,CAACnB,QAAvB;AACAM,UAAAA,UAAU;;AAEV;AACD;AACF;;AAED,UAAI,CAACW,iBAAL,EAAwB;AACtB,eAAO,EAAE/B,KAAK,EAAE,KAAT,EAAP;AACD;AACF,KAxBD,MAwBO,IAAIuB,aAAJ,EAAmB;AACxB,YAAM,EAAEW,KAAF,KAAYX,aAAlB;;AAEA,YAAME,GAAG,GAAGF,aAAa,CAACE,GAAd,GAAoBF,aAAa,CAACE,GAAlC,GAAwC,CAApD,CAHwB,CAG8B;AACtD,YAAMU,GAAG,GAAGZ,aAAa,CAACY,GAAd,GAAoBZ,aAAa,CAACY,GAAlC,GAAwC,OAApD,CAJwB,CAIoC;;AAE5D,UAAIC,KAAK,GAAG,CAAZ;;AAEA;AACA,aAAOA,KAAK,GAAGX,GAAf,EAAoBW,KAAK,EAAzB,EAA6B;AAC3B,cAAMH,WAAW,GAAGpB,eAAe;AACjCL,QAAAA,SADiC;AAEjC0B,QAAAA,KAFiC;AAGjCpB,QAAAA,QAHiC;AAIjC,SAJiC;AAKjCH,QAAAA,SALiC,CAAnC;;;AAQA,YAAIsB,WAAW,CAACjC,KAAhB,EAAuB;AACrBc,UAAAA,QAAQ,GAAGmB,WAAW,CAACnB,QAAvB;AACD,SAFD,MAEO;AACL,iBAAO,EAAEd,KAAK,EAAE,KAAT,EAAP;AACD;AACF;;AAED;AACA,aAAOoC,KAAK,GAAGD,GAAf,EAAoBC,KAAK,EAAzB,EAA6B;AAC3B,cAAMH,WAAW,GAAGpB,eAAe;AACjCL,QAAAA,SADiC;AAEjC0B,QAAAA,KAFiC;AAGjCpB,QAAAA,QAHiC;AAIjC,SAJiC;AAKjCH,QAAAA,SALiC,CAAnC;;;AAQA,YAAIsB,WAAW,CAACjC,KAAhB,EAAuB;AACrBc,UAAAA,QAAQ,GAAGmB,WAAW,CAACnB,QAAvB;AACD,SAFD,MAEO;AACL;AACA;AACD;AACF;;AAEDM,MAAAA,UAAU;AACX,KA5CM,MA4CA,IAAIS,aAAJ,EAAmB;AACxB,YAAM,EAAEK,KAAF,EAASG,IAAT,KAAkBR,aAAxB;;AAEA,YAAMS,aAAa,GAAGzB,eAAe;AACnCL,MAAAA,SADmC;AAEnC0B,MAAAA,KAFmC;AAGnCpB,MAAAA,QAHmC;AAInC,OAJmC;AAKnCH,MAAAA,SALmC,CAArC;;;AAQA,UAAI2B,aAAa,CAACtC,KAAlB,EAAyB;AACvB,cAAMuC,aAAa,GAAGzB,QAAtB;AACAA,QAAAA,QAAQ,GAAGwB,aAAa,CAACxB,QAAzB;;AAEAH,QAAAA,SAAS,CAAC0B,IAAD,CAAT,GAAkB7B,SAAS,CAACgC,KAAV,CAAgBD,aAAhB,EAA+BzB,QAA/B,CAAlB;AACD,OALD,MAKO;AACL,eAAO,EAAEd,KAAK,EAAE,KAAT,EAAP;AACD;;AAEDoB,MAAAA,UAAU;AACX,KArBM,MAqBA;AACL,YAAMqB,cAAc,GAAGjC,SAAS,CAACM,QAAD,CAAhC;;AAEA,UAAI,CAACzB,WAAW,CAACoD,cAAD,EAAiBf,eAAjB,CAAhB,EAAmD;AACjD,eAAO,EAAE1B,KAAK,EAAE,KAAT,EAAP;AACD;;AAEDc,MAAAA,QAAQ;AACRM,MAAAA,UAAU;AACX;AACF;;AAED;AACA;AACA,SAAO,EAAEpB,KAAK,EAAE,KAAT,EAAP;AACD;;AAEM,SAAS0C,mBAAT;AACLlC,SADK;AAELW,WAFK;AAGLwB,SAHK;;;;;;AASO;AACZ,QAAM,EAAE5B,OAAF,EAAWC,MAAX,EAAmBL,SAAnB,KAAiCgC,SAAvC;AACA,QAAMC,SAAS,GAAGpC,SAAS,CAACgC,KAAV,CAAgB,CAAhB,EAAmBzB,OAAnB,CAAlB;;AAEA,QAAM8B,QAAQ,GAAGrC,SAAS,CAACgC,KAAV,CAAgBxB,MAAM,GAAG,CAAzB,CAAjB;AACA,QAAM8B,eAAe,GAAG,EAAxB;;AAEA,OAAK,IAAIC,OAAT,IAAoB5B,WAApB,EAAiC;AAC/B,UAAM6B,cAAc,GAAGD,OAAO,CAACE,8BAAD,CAA9B;;AAEA,QAAID,cAAJ,EAAoB;AAClB,YAAM,EAAEE,QAAF,KAAeF,cAArB;AACA,YAAMG,gBAAgB,GAAGxC,SAAS,CAACuC,QAAD,CAAlC;;AAEA,WAAK,IAAIE,eAAT,IAA4BD,gBAA5B,EAA8C;AAC5CL,QAAAA,eAAe,CAAC9D,IAAhB,CAAqBoE,eAArB;AACD;AACF,KAPD,MAOO;AACLN,MAAAA,eAAe,CAAC9D,IAAhB,CAAqBqE,cAAc,CAACN,OAAD,EAAUpC,SAAV,CAAnC;AACD;AACF;;AAED,SAAOiC,SAAS,CAACU,MAAV,CAAiBR,eAAjB,EAAkCD,QAAlC,CAAP;AACD;;AAED,SAASQ,cAAT,CAAwB1E,MAAxB,EAAqCgC,SAArC,EAAmE;AACjE;AACE,SAAOhC,MAAP,KAAkB,QAAlB;AACA,SAAOA,MAAP,KAAkB,QADlB;AAEA,SAAOA,MAAP,KAAkB,SAHpB;AAIE;AACA,WAAOA,MAAP;AACD;;AAED,QAAM4E,cAAc,GAAG5E,MAAM,CAAC6E,8BAAD,CAA7B;AACA,MAAID,cAAJ,EAAoB;AAClB,UAAM,EAAEL,QAAF,EAAYO,IAAZ,KAAqBF,cAA3B;;AAEA,UAAMJ,gBAAgB,GAAG,EAAzB;;AAEA,SAAK,IAAIO,aAAT,IAA0B/C,SAAS,CAACuC,QAAD,CAAnC,EAA+C;AAC7CC,MAAAA,gBAAgB,CAACnE,IAAjB,CAAsB2E,oBAAoB,CAACD,aAAD,EAAgBD,IAAhB,EAAsB,CAAtB,CAA1C;AACD;;AAED,WAAON,gBAAP;AACD,GAVD,MAUO;AACL,UAAMvE,MAAc,GAAG,EAAvB;AACA,SAAK,IAAIgF,QAAT,IAAqBjF,MAArB,EAA6B;AAC3BC,MAAAA,MAAM,CAACgF,QAAD,CAAN,GAAmBP,cAAc,CAAC1E,MAAM,CAACiF,QAAD,CAAP,EAAmBjD,SAAnB,CAAjC;AACD;;AAED,WAAO/B,MAAP;AACD;AACF;;AAED,SAAS+E,oBAAT,CAA8BhF,MAA9B,EAA2C8E,IAA3C,EAAgExD,EAAhE,EAA4E;AAC1E,MAAIA,EAAE,KAAKwD,IAAI,CAAC1E,MAAL,GAAc,CAAzB,EAA4B;AAC1B,WAAOJ,MAAM,CAAC8E,IAAI,CAACxD,EAAD,CAAL,CAAb;AACD,GAFD,MAEO;AACL,WAAO0D,oBAAoB,CAAChF,MAAM,CAAC8E,IAAI,CAACxD,EAAD,CAAL,CAAP,EAAmBwD,IAAnB,EAAyBxD,EAAE,GAAG,CAA9B,CAA3B;AACD;AACF;;AAEM,SAAS4D,eAAT;AACLrD,SADK;AAELX,YAFK;AAGLiE,cAHK;AAIc;AACnB,QAAMnB,SAAS,GAAG5C,UAAU,CAACS,SAAD,EAAYX,YAAZ,CAA5B;;AAEA,MAAI8C,SAAS,CAAC3C,KAAd,EAAqB;AACnB,WAAO0C,mBAAmB,CAAClC,SAAD,EAAYsD,cAAZ,EAA4BnB,SAA5B,CAA1B;AACD,GAFD,MAEO;AACL,WAAO,IAAP;AACD;AACF","sourcesContent":["// @flow\n\nimport {\n  templTag_arr,\n  templTag_arrOr,\n  templTag_arrRep,\n  templTag_arrVar,\n  templTag_isNull,\n  templTag_in,\n  templTag_notNull,\n  templTag_replArr,\n  templTag_replObj,\n} from './templateTags'\n\nexport function stringToTokenArray(source: string) {\n  const result = []\n\n  let accumulated = ''\n  for (let c of source) {\n    if (\n      (c >= 'a' && c <= 'z') ||\n      (c >= 'A' && c <= 'Z') ||\n      (c >= '0' && c <= '9')\n    ) {\n      accumulated += c\n    } else {\n      if (accumulated.length > 0) {\n        result.push({ word: { text: accumulated.toLowerCase() } })\n        accumulated = ''\n      }\n      if (c !== ' ') {\n        result.push({ symbol: { text: c } })\n      }\n    }\n  }\n\n  if (accumulated.length > 0) {\n    result.push({ word: { text: accumulated.toLowerCase() } })\n    accumulated = ''\n  }\n\n  return result\n}\n\nexport function matchObject(token: any, condition: any): boolean {\n  if (\n    typeof condition === 'string' ||\n    typeof condition === 'number' ||\n    typeof condition === 'boolean'\n  ) {\n    return token === condition\n  }\n\n  // Check for in condition\n  if (typeof condition === 'object') {\n    const inCondition = condition[templTag_in]\n\n    if (inCondition) {\n      // In condition - match until one match is found\n      for (let inConditionOption of inCondition) {\n        if (matchObject(token, inConditionOption)) {\n          return true\n        }\n      }\n    }\n\n    // Compare constant arrays\n    if (Array.isArray(token)) {\n      // If token is array, condition should also be an array, or array template\n      if (!Array.isArray(condition)) {\n        const templateInfo = condition[templTag_arr]\n\n        if (templateInfo) {\n          return matchArray(token, templateInfo).match\n        } else {\n          return false\n        }\n      }\n\n      // For arrays, make sure they have the same length\n      if (token.length !== condition.length) {\n        return false\n      }\n    } // if ( Array.isArray( token ) )\n\n    for (let ix in condition) {\n      const tokenValue = token[ix]\n      const conditionValue = condition[ix]\n\n      if (conditionValue === templTag_notNull) {\n        if (tokenValue == null) {\n          return false\n        } else {\n          continue\n        }\n      }\n      if (conditionValue === templTag_isNull) {\n        if (tokenValue != null) {\n          return false\n        } else {\n          continue\n        }\n      }\n\n      const typeOfValue = typeof tokenValue\n      const typeOfCondition = typeof conditionValue\n\n      if (typeOfCondition === 'object') {\n        // Regular object - match recursively, if the object is of the same type\n\n        if (typeOfValue !== typeOfCondition) {\n          return false\n        }\n        if (!matchObject(tokenValue, conditionValue)) {\n          return false\n        }\n      } else {\n        if (tokenValue !== conditionValue) {\n          return false\n        }\n      } // if ( typeOfCondition === 'object' )\n    } // for ( let ix in condition )\n  } // if ( typeof condition === 'object' )\n\n  return true\n}\n\nexport function matchArray(\n  arrTokens: Array<any>,\n  templateInfo: { float?: boolean, template: Array<any> },\n):\n  | { match: false }\n  | {\n      ixStart: number,\n      ixStop: number,\n      match: true,\n      variables: { [string]: any },\n    } {\n  const { template, float } = templateInfo\n\n  const variables: { [string]: any } = {}\n\n  if (!float) {\n    const tryMatchWhole = matchArrayPiece(arrTokens, template, 0, 0, variables)\n\n    if (!tryMatchWhole.match) {\n      return { match: false }\n    } else if (tryMatchWhole.ixTokens === arrTokens.length) {\n      return {\n        ixStart: 0,\n        ixStop: arrTokens.length - 1,\n        match: true,\n        variables,\n      }\n    } else {\n      return { match: false }\n    }\n  } else {\n    const lenPayload = arrTokens.length\n\n    for (let ixStart = 0; ixStart < lenPayload; ixStart++) {\n      const tryMatchPart = matchArrayPiece(\n        arrTokens,\n        template,\n        ixStart,\n        0,\n        variables,\n      )\n\n      if (tryMatchPart.match) {\n        return {\n          ixStart,\n          ixStop: tryMatchPart.ixTokens - 1,\n          match: true,\n          variables,\n        }\n      }\n    }\n\n    // Template not found, so it is false\n    return { match: false }\n  }\n}\n\nfunction matchArrayPiece(\n  arrTokens: Array<any>,\n  arrTemplate: Array<any>,\n  ixTokens: number,\n  ixTemplate: number,\n  variables: { [string]: any },\n): { match: false } | { match: true, ixTokens: number, ixTemplate: number } {\n  const lengthTokens = arrTokens.length\n  const lengthTemplate = arrTemplate.length\n\n  for (;;) {\n    // No more template elements\n    if (ixTemplate >= lengthTemplate) {\n      return { match: true, ixTokens, ixTemplate }\n    }\n\n    // No more token\n    if (ixTokens >= lengthTokens) {\n      // We are out of tokens, but not out of template. The only way for this to be a match\n      // is for the rest of the template to be templTag_arrOr with min = 0. Check if this\n      // is the case\n      for (; ixTemplate < lengthTemplate; ixTemplate++) {\n        const arrRepOptions = arrTemplate[ixTemplate][templTag_arrRep]\n\n        if (arrRepOptions && arrRepOptions.min === 0) continue\n        else break\n      }\n\n      // Going through the loop exhausted the rest of the template?\n      if (ixTemplate >= lengthTemplate) {\n        return { match: true, ixTokens, ixTemplate }\n      }\n\n      return { match: false }\n    }\n\n    const elementTemplate = arrTemplate[ixTemplate]\n    const arrOrOptions = elementTemplate[templTag_arrOr]\n    const arrRepOptions = elementTemplate[templTag_arrRep]\n    const arrVarOptions = elementTemplate[templTag_arrVar]\n\n    if (arrOrOptions) {\n      let bOptionMatchFound = false\n      for (let orOption of arrOrOptions) {\n        const optionMatch = matchArrayPiece(\n          arrTokens,\n          orOption,\n          ixTokens,\n          0,\n          variables,\n        )\n\n        if (optionMatch.match) {\n          bOptionMatchFound = true\n\n          ixTokens = optionMatch.ixTokens\n          ixTemplate++\n\n          break\n        }\n      }\n\n      if (!bOptionMatchFound) {\n        return { match: false }\n      }\n    } else if (arrRepOptions) {\n      const { items } = arrRepOptions\n\n      const min = arrRepOptions.min ? arrRepOptions.min : 0 // Optional by default\n      const max = arrRepOptions.max ? arrRepOptions.max : 1000000 // A very, very high max means no max\n\n      let found = 0\n\n      // First, make sure that there is enough minimum matches\n      for (; found < min; found++) {\n        const optionMatch = matchArrayPiece(\n          arrTokens,\n          items,\n          ixTokens,\n          0,\n          variables,\n        )\n\n        if (optionMatch.match) {\n          ixTokens = optionMatch.ixTokens\n        } else {\n          return { match: false }\n        }\n      }\n\n      // And continue matching until we reach max, or fail a match\n      for (; found < max; found++) {\n        const optionMatch = matchArrayPiece(\n          arrTokens,\n          items,\n          ixTokens,\n          0,\n          variables,\n        )\n\n        if (optionMatch.match) {\n          ixTokens = optionMatch.ixTokens\n        } else {\n          // If we do not match, we can simply exit this loop\n          break\n        }\n      }\n\n      ixTemplate++\n    } else if (arrVarOptions) {\n      const { items, name } = arrVarOptions\n\n      const variableMatch = matchArrayPiece(\n        arrTokens,\n        items,\n        ixTokens,\n        0,\n        variables,\n      )\n\n      if (variableMatch.match) {\n        const ixTokensStart = ixTokens\n        ixTokens = variableMatch.ixTokens\n\n        variables[name] = arrTokens.slice(ixTokensStart, ixTokens)\n      } else {\n        return { match: false }\n      }\n\n      ixTemplate++\n    } else {\n      const elementPayload = arrTokens[ixTokens]\n\n      if (!matchObject(elementPayload, elementTemplate)) {\n        return { match: false }\n      }\n\n      ixTokens++\n      ixTemplate++\n    }\n  }\n\n  // This line is placed here to please flow\n  // eslint-disable-next-line no-unreachable\n  return { match: false }\n}\n\nexport function replaceMatchInArray(\n  arrTokens: Array<any>,\n  arrTemplate: Array<any>,\n  matchInfo: {\n    ixStart: number,\n    ixStop: number,\n    match: true,\n    variables: { [string]: any },\n  },\n): Array<any> {\n  const { ixStart, ixStop, variables } = matchInfo\n  const arrBefore = arrTokens.slice(0, ixStart)\n\n  const arrAfter = arrTokens.slice(ixStop + 1)\n  const arrReplacements = []\n\n  for (let element of arrTemplate) {\n    const optionsReplArr = element[templTag_replArr]\n\n    if (optionsReplArr) {\n      const { variable } = optionsReplArr\n      const arrVariableValue = variables[variable]\n\n      for (let variableElement of arrVariableValue) {\n        arrReplacements.push(variableElement)\n      }\n    } else {\n      arrReplacements.push(replaceReplObj(element, variables))\n    }\n  }\n\n  return arrBefore.concat(arrReplacements, arrAfter)\n}\n\nfunction replaceReplObj(source: any, variables: { [string]: any }) {\n  if (\n    typeof source === 'string' ||\n    typeof source === 'number' ||\n    typeof source === 'boolean'\n  ) {\n    return source\n  }\n\n  const optionsReplObj = source[templTag_replObj]\n  if (optionsReplObj) {\n    const { variable, path } = optionsReplObj\n\n    const arrVariableValue = []\n\n    for (let variableValue of variables[variable]) {\n      arrVariableValue.push(retrieveObjectAtPath(variableValue, path, 0))\n    }\n\n    return arrVariableValue\n  } else {\n    const result: Object = {}\n    for (let propName in source) {\n      result[propName] = replaceReplObj(source[propName], variables)\n    }\n\n    return result\n  }\n}\n\nfunction retrieveObjectAtPath(source: any, path: Array<string>, ix: number) {\n  if (ix === path.length - 1) {\n    return source[path[ix]]\n  } else {\n    return retrieveObjectAtPath(source[path[ix]], path, ix + 1)\n  }\n}\n\nexport function matchAndReplace(\n  arrTokens: Array<any>,\n  templateInfo: { float?: boolean, template: Array<any> },\n  arrReplacement: Array<any>,\n): null | Array<any> {\n  const matchInfo = matchArray(arrTokens, templateInfo)\n\n  if (matchInfo.match) {\n    return replaceMatchInArray(arrTokens, arrReplacement, matchInfo)\n  } else {\n    return null\n  }\n}\n"],"file":"template.js"}